import {AisleStructureEntry, Subaisle} from "@/defs/map-locations-defs";
import dayjs from "dayjs";
import {getIsoDate} from "@/defs/date-handling";

export class MapDTO {
    id: number | null = null;
    width: number = 0;
    height: number = 0;

    constructor(id: number | null, width: number, height: number) {
        this.id = id;
        this.width = width;
        this.height = height;
    }
}

export class MapTileDTO {
    id: number | null;
    x: number;
    y: number;
    tile_type: string;
    subaisle: Subaisle | null;
    color: string | null; // Colors are generated by editor and saved in the DB
    color_is_light: boolean;

    constructor(
        id: number | null, x: number, y: number, tile_type: string, subaisle: Subaisle | null,
        color: string | null = null, color_is_light: boolean = true,
    ) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.tile_type = tile_type;
        this.subaisle = subaisle;
        this.color = color;
        this.color_is_light = color_is_light;
    }

    public static fromMapTile(tile: MapTile) {
        return new MapTileDTO(tile.id, tile.x, tile.y, tile.tileType, tile.subaisle);
    }
}

export enum TileType {
    ENTRANCE = "entrance",
    EXIT = "exit",
    ENTRANCE_EXIT = "ee",
    REGISTER = "register",
    PRODUCT = "product",
    SUBAISLE = "subaisle",
    SPACE = "space",
    BLOCK = "block"
}

export const TILE_TYPE_NAMES: Map<TileType, string> = new Map();
TILE_TYPE_NAMES.set(TileType.ENTRANCE, gettext("Entrance"));
TILE_TYPE_NAMES.set(TileType.EXIT, gettext("Exit"));
TILE_TYPE_NAMES.set(TileType.ENTRANCE_EXIT, gettext("Entrance + Exit"));
TILE_TYPE_NAMES.set(TileType.REGISTER, gettext("Cash register"));
TILE_TYPE_NAMES.set(TileType.PRODUCT, gettext("Product shelf (without subaisle)"));
TILE_TYPE_NAMES.set(TileType.SPACE, gettext("Space between aisles"));
TILE_TYPE_NAMES.set(TileType.SUBAISLE, gettext("Subaisle"));
TILE_TYPE_NAMES.set(TileType.BLOCK, gettext("Inaccessible tile"));

export function getTileTypeName(tileType: TileType): string {
    return TILE_TYPE_NAMES.get(tileType) || "?";
}

export function columnLetter(x: number): string {
    if (x >= 26) {
        const first = Math.floor(x / 26) - 1;
        const second = x % 26;
        return String.fromCharCode(0x41 + first, 0x41 + second);
    }
    return String.fromCharCode(0x41 + x);
}

export class MapTile {
    public id: number | null;
    public x: number;
    public y: number;
    public tileType: TileType;
    public subaisle: Subaisle | null;

    constructor(id: number | null, x: number, y: number, tileType: TileType, subaisle: Subaisle | null) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.tileType = tileType;
        this.subaisle = subaisle;
    }

    public static fromDTO(tile: MapTileDTO) {
        return new MapTile(tile.id, tile.x, tile.y, tile.tile_type as TileType, tile.subaisle);
    }

    get key(): string {
        return this.subaisle === null ? "" : this.subaisle.display_code;
    }

    get letterCoords(): string {
        return `${columnLetter(this.x)}${this.y + 1}`;
    }

    get tileText(): string {
        return this.subaisle === null ? getTileTypeName(this.tileType) : this.subaisle.name;
    }

    get letterCoordsWithText(): string {
        return `${this.letterCoords}: ${this.tileText}`;
    }
}

export class MapTileRow {
    public y: number;
    public tiles: MapTile[];

    constructor(y: number, tiles: MapTile[] = []) {
        this.y = y;
        this.tiles = tiles;
    }
}

export class StoreMap {
    public id: number | null;
    public width: number;
    public height: number;
    public tiles: MapTile[];

    public constructor(id: number | null, width: number, height: number, tiles: MapTile[]) {
        this.id = id;
        this.width = width;
        this.height = height;
        this.tiles = tiles;
    }

    public static fromDTOs(map: MapDTO, tiles: MapTileDTO[]): StoreMap {
        return new StoreMap(
            map.id, map.width, map.height,
            tiles.map((mtd) => new MapTile(mtd.id, mtd.x, mtd.y, mtd.tile_type as TileType, mtd.subaisle)),
        );
    }

    public toMapDTO(): MapDTO {
        return new MapDTO(this.id, this.width, this.height);
    }
}

export interface AppDataMSD {
    map: MapDTO;
    tiles: MapTileDTO[];
    aisles: AisleStructureEntry[];
}

export interface AppDataSME {
    map: MapDTO | null;
    defaultSize: number;
    tiles: MapTileDTO[];
    aisles: AisleStructureEntry[];
    aislesEndpoint: string;
    saveEndpoint: string;
}

export class MapSaveRequest {
    map: MapDTO;
    tiles: MapTileDTO[];
    date: string;

    constructor(map: MapDTO, tiles: MapTileDTO[], date: string) {
        this.map = map;
        this.tiles = tiles;
        this.date = date;
    }
}

export interface MapSaveResponse {
    success: boolean;
    message: string;
    warning: boolean;
    map: MapDTO | null;
    tiles: MapTileDTO[];
}

export async function getAisles(endpoint: string, validAt: string | dayjs.Dayjs): Promise<AisleStructureEntry[]> {
    const url: URL = new URL(endpoint, document.location.toString());
    url.searchParams.set("validAt", getIsoDate(validAt));

    const req = await fetch(url.toString(), {credentials: "same-origin"});
    return req.json();
}

export async function saveMap(endpoint: string, mapDTO: MapDTO, tileDTOs: MapTileDTO[],
                              validAt: string): Promise<MapSaveResponse> {
    const data = new MapSaveRequest(mapDTO, tileDTOs, validAt);
    const body = JSON.stringify(data);
    const csrftoken = (document.querySelector("[name=csrfmiddlewaretoken]") as HTMLInputElement).value;
    const headers = new Headers();
    headers.set("X-CSRFToken", csrftoken);
    const req = await fetch(endpoint, {
        credentials: "same-origin",
        method: "POST",
        body,
        headers,
    });
    return req.json();
}

export function sortedMapTiles(tiles: MapTile[]) {
    return tiles.sort((t1: MapTile, t2: MapTile) => t1.x - t2.x || t1.y - t2.y);
}
